target C {
    coordination: decentralized,
}

reactor DistAlg(ownId:int(0), STP_offset:time(0 msec)) {
    preamble {=
        void findIndexSmallestValues(int* arr, int* closestArr, int n) {
            int min1 = arr[0];
            int pos1 = 0;
            int min2 = arr[1];
            int pos2 = 1;

            if (min2 < min1) {
                min1 = arr[1];
                pos1 = 1;
                min2 = arr[0];
                pos2 = 0;
            }
            for (int i = 2; i < n; i++) {
                if (arr[i] < min1) {
                    min2 = min1;
                    pos2 = pos1;
                    min1 = arr[i];
                    pos1 = i;
                } else if (arr[i] < min2) {
                    min2 = arr[i];
                    pos2 = i;
                }
            }
            closestArr[0] = pos1;
            closestArr[1] = pos2;
        }

        int localAction(int closestRelays[], int ownId) {
            if (ownId == closestRelays[0] || ownId == closestRelays[1]) {
                return 1;
            } else {
                return 0;
            }
        }

        int decideLocalAction(int* arr, int ownId, int numUnits) {
            int closestRelays[2];
            findIndexSmallestValues(arr, closestRelays, numUnits);
            return localAction(closestRelays, ownId);
        }
    =}

    output distributedDecision:int
    input voltageReportAIn:int
    input voltageReportBIn:int
    input voltageReportCIn:int
    input voltageReportDIn:int
    state voltages:int[] = {0, 0, 0, 0}
    state numReports:int(0)
    state result:bool (false)
    reaction(voltageReportAIn, voltageReportBIn, voltageReportCIn, voltageReportDIn) -> distributedDecision {=
        if (voltageReportAIn->is_present && voltageReportBIn->is_present && voltageReportCIn->is_present && voltageReportDIn->is_present) {
            self->voltages[0] = voltageReportAIn->value;
            self->voltages[1] = voltageReportBIn->value;
            self->voltages[2] = voltageReportCIn->value;
            self->voltages[3] = voltageReportDIn->value;
            self->result = decideLocalAction(self->voltages, self->ownId, 4);
            //printf("Setting relay %u to %u (1=open,0=close)\n", self->ownId, result);
            lf_set(distributedDecision, self->result);
        }
    =} STP(0) {=
        printf("STP violation: Did not receive inputs in time, opening circuit as default.\n");

        //debugging
        if (((lf_time_logical_elapsed() - (voltageReportAIn->intended_tag.time - lf_time_start()) > 0) || 
           ((lf_time_logical_elapsed() - (voltageReportAIn->intended_tag.time - lf_time_start()) == 0) && 
           ((lf_tag().microstep - voltageReportAIn->intended_tag.microstep) > 0))) &&
           (voltageReportAIn->is_present)) {
            printf("Input from A was tardy.\n");
        }

        if (((lf_time_logical_elapsed() - (voltageReportBIn->intended_tag.time - lf_time_start()) > 0) || 
           ((lf_time_logical_elapsed() - (voltageReportBIn->intended_tag.time - lf_time_start()) == 0) && 
           ((lf_tag().microstep - voltageReportBIn->intended_tag.microstep) > 0))) &&
           (voltageReportBIn->is_present)) {
            printf("Input from B was tardy.\n");
        }

        if (((lf_time_logical_elapsed() - (voltageReportCIn->intended_tag.time - lf_time_start()) > 0) || 
           ((lf_time_logical_elapsed() - (voltageReportCIn->intended_tag.time - lf_time_start()) == 0) && 
           ((lf_tag().microstep - voltageReportCIn->intended_tag.microstep) > 0))) &&
           (voltageReportCIn->is_present)) {
            printf("Input from C was tardy.\n");
        }

        if (((lf_time_logical_elapsed() - (voltageReportDIn->intended_tag.time - lf_time_start()) > 0) || 
           ((lf_time_logical_elapsed() - (voltageReportDIn->intended_tag.time - lf_time_start()) == 0) && 
           ((lf_tag().microstep - voltageReportDIn->intended_tag.microstep) > 0))) &&
           (voltageReportDIn->is_present)) {
            printf("Input from D was tardy.\n");
        }
    =}
}

reactor CircuitStatus(STP_offset:time(0 msec)) {
    preamble {=
        void openCircuit() {
            // led turns on
        }

        void closeCircuit() {
            // led turns off
        }
    =}

    input distributedDecision:int
    input countdown:int
    logical action breakCircuit;
    state faultHandled:int;

    reaction(startup){=
    =}

    reaction(countdown) -> breakCircuit {=
        self->faultHandled = 0;
        lf_schedule(breakCircuit, MSEC(150));
    =} STP(0) {=
        //printf("STP violation for countdown\n");
    =}

    reaction(breakCircuit) {=
        if (self->faultHandled){
            // This relay is not the closest to the fault
            //printf("FAult already handled.\n");
        } else {
            //printf("Opening circuit since 150 msec has passed.\n");
            openCircuit();
        }
    =} STP(0) {=
        //printf("STP violation for breakcircuit.\n");
    =}

    reaction(distributedDecision) -> breakCircuit {=
        if (distributedDecision->value) {
            //printf("Distributed decision decided to open this circuit.\n");
            openCircuit();
            self->faultHandled = 1;
        } else {
            //printf("Distributed decision decided to close this circuit.\n");
            closeCircuit();
            self->faultHandled = 1;
        }
    =} STP(0) {=
        //printf("STP violation for distributed decision.\n");
    =}
}

reactor VoltageSensor(id:int(0)) {

    preamble{=
        #define VOLTAGE_LIMIT 14000U

        // Voltage measurement timeseries
        int simMeas[4][14] ={{15000,15000,13100,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,11000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,11200,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000},
                            {15000,15000,12500,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000,15000}};

        int readSensor(int id, int count) {
            return simMeas[id][count];
        }
    =}

    timer t(1 sec, 70 msec);
    output[4] measOut:int
    output startCountdown:int
    state measCount:int(0)

    reaction(startup){=
    =}

    reaction(t) -> measOut, startCountdown {=

        // Read simulated measurement 
        int voltageMeasurement = readSensor(self->id, self->measCount);
        if (self->measCount == 13) {
            self->measCount = 0;
            lf_request_stop();
        } else {
            self->measCount++;
        }

        // Check if short circuit has occured on the line
        if (voltageMeasurement < VOLTAGE_LIMIT) {
            //printf("SEND\n");
            // A fault has occured, let other nodes know
            lf_set(startCountdown, 1);
            for (int i = 0; i < 4; i++) {
                lf_set(measOut[i], voltageMeasurement);
            }
        }
    =}
}

reactor RelayUnit(id:int(0), STP_offset:time(0 msec)) {
    output[4] voltageReportOut:int;
    input voltageReportAIn:int;
    input voltageReportBIn:int;
    input voltageReportCIn:int;
    input voltageReportDIn:int;

    circuitStatus = new CircuitStatus();
    voltageSensor = new VoltageSensor(id = id);
    distAlg = new DistAlg(ownId = id);

    voltageSensor.measOut -> voltageReportOut;
    voltageSensor.startCountdown -> circuitStatus.countdown;

    voltageReportAIn -> distAlg.voltageReportAIn;
    voltageReportBIn -> distAlg.voltageReportBIn;
    voltageReportCIn -> distAlg.voltageReportCIn;
    voltageReportDIn -> distAlg.voltageReportDIn;
    
    distAlg.distributedDecision -> circuitStatus.distributedDecision;

}

federated reactor at 192.0.2.2:15047 {
    unitA = new RelayUnit(id = 0);
    unitB = new RelayUnit(id = 1);
    unitC = new RelayUnit(id = 2);
    unitD = new RelayUnit(id = 3);

    unitA.voltageReportOut -> unitA.voltageReportAIn, 
                              unitB.voltageReportAIn, 
                              unitC.voltageReportAIn, 
                              unitD.voltageReportAIn after 15 msec;

    unitB.voltageReportOut -> unitA.voltageReportBIn, 
                              unitB.voltageReportBIn, 
                              unitC.voltageReportBIn, 
                              unitD.voltageReportBIn after 15 msec;

    unitC.voltageReportOut -> unitA.voltageReportCIn, 
                              unitB.voltageReportCIn, 
                              unitC.voltageReportCIn, 
                              unitD.voltageReportCIn after 15 msec;

    unitD.voltageReportOut -> unitA.voltageReportDIn, 
                              unitB.voltageReportDIn, 
                              unitC.voltageReportDIn, 
                              unitD.voltageReportDIn after 15 msec;

    // reaction(startup){=
    //     interval_t stp = 00000000LL;
    //     lf_set_stp_offset(stp);
    // =}
}
